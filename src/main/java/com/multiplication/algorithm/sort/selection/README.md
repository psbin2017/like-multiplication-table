# 선택 정렬

1. 앞에서부터 n 까지 비교 연산한다.
2. 작은 값이 나오면 마킹한다.
3. 마킹된 곳과 앞자리를 교환한다.
4. 앞자리는 가장 작은 값으로 결정되며 비교 범위를 좁히고 반복한다. (1 ~ n)

## 예시

```text
[10, 1, 6, 7]

// 1 loop
[10, 1, 6, 3]: arr[0] 과 arr[1] 을 비교, 최소값 1 과 인덱스 1 을 마킹
[10, 1, 6, 3]: arr[0] 과 arr[2] 을 비교, 마킹에 변화 없음
[10, 1, 6, 3]: arr[0] 과 arr[3] 을 비교, 마킹에 변화 없음

[1, 10, 6, 3]: 마킹되었었던 위치를 서로 교환함

// 2 loop
[1] [10, 6, 3]: arr[1] 과 arr[2] 을 비교, 최소값 6 과 인덱스 2 를 마킹
[1] [10, 6, 3]: arr[1] 과 arr[3] 을 비교, 최소값 3 과 인덱스 3 를 마킹

[1, 3, 6, 10]: 마킹되어있었던 위치를 서로 교환함

// 3 loop
[1, 3] [6, 10]: arr[2] 과 arr[3] 을 비교, 마킹에 변화 없음

[1, 3, 6, 10]: 마킹되어있었던 위치를 서로 교환함 (변화 없음)
```

- 배열의 길이가 4일 때 6번 (3 + 2 + 1) 비교 연산을 수행함
- 배열의 길이가 5일 때 10번 (4 + 3 + 2 + 1) 비교 연산을 수행함
- 배열의 길이가 6일 때 15번 (5 + 4 + 3 + 2 + 1) 비교 연산을 수행함

## 시간 복잡도

- 이중 for 문을 사용하여 O(n<sup>2</sup>)

## 공간 복잡도

- 배열 하나만 사용하여 O(n)
