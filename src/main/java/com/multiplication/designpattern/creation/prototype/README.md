# 프로토타입

> 생성할 객체들의 타입이 프로토타입인 인스턴스로부터 결정되도록 하며, 인스턴스는 새 객체를 만들기 위해 자신을 복제(clone)하게 된다.

## 의도

원형이 되는(prototypical) 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서 새로운 객체를 생성한다.

## 활용

제품의 생성, 복합, 표현 방법에 독립적인 제품을 만들고자 할 때 사용한다.

- 인스턴스화할 클래스를 런타임에 지정할 때(동적 로딩)
- 제품 클래스 계통과 병렬적으로 만드는 팩토리 클래스를 피하고 싶을 때
- 클래스의 인스턴스들이 서로 다른 상태 조합 중에 어느 하나일 때

이 들을 미리 원형으로 초기화하곡 나중에 이를 복제하여 사용하는 것이 매번 필요한 상태 조합의 값들을 수동적으로 초기화하는 것보다 편리하다.

## 참여자

- `Prototype`: 자신을 복제하는 데 필요한 인터페이스를 정의한다.
- `ConcretePrototype`: 자신을 복제하는 연산을 구현한다.
- `Client`: 원형에 자기 자신의 복제를 요청하여 새로운 객체를 생성한다.

## 결과

원형 패턴은 추상 팩토리 및 빌더와 비슷한 결과를 나타낸다. 사용자 쪽에서는 어떤 구체적인 제품이 있는지 알리지 않아도 되기 때문에 사용자 쪽에서 상대해야하는 클래스의 수가 적다.

1. 런타임에 새로운 제품을 추가하고 삭제할 수 있다.
   - 원형으로 생성되는 인스턴스를 등록하는 것만으로도 시스템에 새로운 제품 클래스를 추가할 수 있다.
   - 런타임에 새로운 원형을 넣고 빼기 쉬워 다른 생성 패턴에 비해 유연성을 지닌다.
2. 값들을 다양화함으로써 새로운 객체를 명세한다.
3. 구조를 다양화함으로써 새로운 객체를 명세할 수 있다.
   - 구성요소와 부분 구성요소의 복합을 통해 객체를 구축한다.
4. 서브클래스의 수를 줄인다.
5. 동적으로 클래스에 따라 응용프로그램을 설정할 수 있다.

## 구현

1. 원형 관리자를 사용한다.
   - 사용자는 원형 자체를 다루지 않고 레지스트리에서 원형을 검색하고 그것을 레지스트리에 저장한다.
   - 사용자는 레지스트리에 원형이 있는지 알아보는데 이런 레지스트리를 가리켜 원형 관리자라고 한다. 
2. `clone()` 연산을 구현한다.
   - 얕은 복사(shallow copy): Clone 객체의 변경이 Original 객체에 영향을 줄 수 있다. (반대도 동일, 동일한 참조를 가지기 때문) 
   - 깊은 복사(deep copy): Original 객체와 Clone 객체가 서로 독립적. (`Cloneable`) ... [effective Java 주의사항](https://github.com/psbin2017/basic-total/tree/master/java/books/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%20%EC%9E%90%EB%B0%94/chapter03%20%EB%AA%A8%EB%93%A0%20%EA%B0%9D%EC%B2%B4%EC%9D%98%20%EA%B3%B5%ED%86%B5%20%EB%A9%94%EC%84%9C%EB%93%9C/item13%20clone%20%EC%9E%AC%EC%A0%95%EC%9D%98%EB%8A%94%20%EC%A3%BC%EC%9D%98%ED%95%B4%EC%84%9C%20%EC%A7%84%ED%96%89%ED%95%98%EB%9D%BC)
3. `clone()` 을 초기화한다.
   -

## 연관 패턴

프로토타입 패턴과 추상 팩토리 패턴은 어떤 면에서는 경쟁 관계이다. 그러나 같이 사용할 수 있다. 추상 팩토리가 원형의 집합을 저장하고 있다가 필요할 때 복제하여 제품 객체를 반환하도록 사용할 수 있다.